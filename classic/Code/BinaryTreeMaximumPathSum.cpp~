#include <cstddef>
#include <iostream>
#include <map>
#include <stack>
using namespace std;
/**
 * Definition for binary tree
*/

  struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  };

class Solution {
public:
	int maxPathSum(TreeNode *root) {
    	map<TreeNode*, pair<int,int> > rawMap;
		calc(root,&rawMap);
		map<TreeNode*, pair<int,int> >::iterator p;
  		int maximum=-1e6;
  		for(p = rawMap.begin(); p != rawMap.end(); p++) {
			int childMax=max(p->second.first,p->second.second);
			int allMax=max(p->second.first+p->second.second+p->first->val,0);
			int val=max(childMax,allMax);
			if(val>maximum)maximum=val;
		}
		if(maximum==0)return singleMax(root);
		return maximum;
	}
	int singleMax(TreeNode* root){
		stack<TreeNode*> stack;
		stack.push(root);
		int max=-1e6;
		while(!stack.empty()){
			int val=stack.top()->val;
			stack.pop();
			if(val>max){max=val;}
			if(root->left!=NULL)stack.push(root->left);
			if(root->right!=NULL)stack.push(root->right);
		}
		return max;
	}
	int calc(TreeNode*root, map<TreeNode*,pair<int,int> >*map){
		if(root->left==NULL&&root->right!=NULL){
			pair<int,int> val;
			if(map->count(root)){
				return max(max(map->find(root)->second.first,map->find(root)->second.second),0);
			}else{
				val= pair<int,int>(0,max(calc(root->right, map),0));
				map->insert(pair<TreeNode*,pair<int,int> >(root,val));
			}
			return max(max(val.first+root->val,0),max(val.second+root->val,0));
		}else if(root->left!=NULL&&root->right==NULL){
			pair<int,int> val;
			if(map->count(root)){
				return max(max(map->find(root)->second.first,map->find(root)->second.second),0);
			}else{
				val= pair<int,int>(max(calc(root->left, map),0),0);
				map->insert(pair<TreeNode*,pair<int,int> >(root,val));
			}
			return max(max(val.first+root->val,0),max(val.second+root->val,0));
		}else if(root->left==NULL&&root->right==NULL){
			pair<int,int> val;
            if(map->count(root)){
				return max(max(map->find(root)->second.first,map->find(root)->second.second),0);
			}else{
				val=pair<int,int>(0, 0);
				map->insert(pair<TreeNode*,pair<int,int> >(root,val));
			}
			return max(max(val.first+root->val,0),max(val.second+root->val,0));
		}else if(root->left!=NULL&&root->right!=NULL){
			pair<int,int> val;
			if(map->count(root)){
				return max(max(map->find(root)->second.first,map->find(root)->second.second),0);
			}else{
				val=pair<int,int>(max(calc(root->left,map),0),max(calc(root->right,map),0));
				map->insert(pair<TreeNode*,pair<int,int> >(root,val));
			}
			return max(max(val.first+root->val,0),max(val.second+root->val,0));
		}
	}
};

void build(TreeNode*node){
	node->left=new TreeNode(2);
	node->right=new TreeNode(3);
}

int main(){
	Solution s;
	TreeNode*root=new TreeNode(1);
	build(root);
	cout<<s.maxPathSum(root)<<endl;
}
